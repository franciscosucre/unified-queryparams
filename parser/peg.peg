Query = Expression+

Expression = key:Key operator:Operator value:Value _ connector:Connector _ tail:Expression { 
        let head;
        if (operator != ':') head = { [key]: { [operator]: value } }
        else head = { [key]: value }
        return {[connector]: [head, tail] }
    }
	/ key:Key operator:Operator value:Value _ connector:Connector _ "(" _ tail:Expression _ ")" { 
        let head;
        if (operator != ':') head = { [key]: { [operator]: value } }
        else head = { [key]: value }
        return {[connector]: [head, tail] }
    }
    / key:Key _ connector:Connector _ tail:Expression _ { 
    	const head = { $text: {$search: key} }
        return { [connector] : [head, tail] }
    }
    / key:Key _ connector:Connector _ "(" _ tail:Expression _ ")" { 
        const head = { $text: {$search: key} }
        return { [connector] : [head, tail] }
    }
	/ key:Key operator:Operator value:Value { 
    	if (operator != ':') return { [key]: { [operator]: value } }
        else return { [key]: value }
    }
    / key:Key { return {$text:{$search: key }}  }

Key = key:([0-9a-zA-Z_$\-.]+) { return key.join('') }

Value = value:([a-zA-Z0-9@.\-:_]+) { 
	value = value.join('')
	const isNumber = !isNaN(parseFloat(value)),
    isDate = isNaN(value) && !isNaN(Date.parse(new Date(value))),
    isBoolean = value == "true" || value == "false";
	
    if (isDate) {
    	return new Date(value);
    } else if (isNumber) {
    	return parseFloat(value);
    } else if (isBoolean) {
    	return value == "true" ? true : false;
    } else {
    	return new RegExp(value, "i");
    }
}

Connector = "AND" { return "$and" }
	/ "OR" { return "$or" }

Operator = ":==" { return "$eq" }
	/ ":!=" { return "$neq" }
    / ":>=" { return "$gte" }
    / ":<=" { return "$lte" }
    / ":>" { return "$gt" }
    / ":<" { return "$lt" }
    / ":"
    
_ "Whitespace" = " "*
